<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Manitas</title>

    <style>
      /* Estilos anteriores */
      body {
        font-family: roboto;
        margin: 2em;
        color: #3d3d3d;
      }

      h1 {
        color: #007f8b;
      }

      section {
        opacity: 1;
        transition: opacity 500ms ease-in-out;
      }

      .invisible {
        opacity: 0.2;
      }

      .detectOnClick {
        position: relative;
        float: left;
        width: 48%;
        margin: 2% 1%;
        cursor: pointer;
      }

      .videoView {
        position: absolute;
        float: left;
        width: 48%;
        margin: 2% 1%;
        cursor: pointer;
        min-height: 500px;
      }

      .detectOnClick p {
        padding-top: 5px;
        padding-bottom: 5px;
        background-color: #007f8b;
        color: #fff;
        border: 1px dashed rgba(255, 255, 255, 0.7);
        z-index: 2;
        margin: 0;
      }

      .canvas {
        z-index: 1;
        position: absolute;
        pointer-events: none;
      }

      .detectOnClick {
        z-index: 0;
        font-size: calc(8px + 1.2vw);
      }

      .output {
        display: none;
        width: 100%;
        font-size: calc(8px + 1.2vw);
      }

      /* Nuevos estilos para la lista de gestos */
      #lastGestures {
        position: fixed;
        top: 0;
        right: 0;
        padding: 10px;
        background-color: #f0f0f0;
      }

      #lastGestures h2 {
        margin-bottom: 5px;
      }

      #gestureList {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      #gestureList li {
        margin-bottom: 5px;
      }
    </style>

    <script>
      window.console = window.console || function (t) {};
    </script>
  </head>

  <body translate="no">
    <h1>Manitas</h1>

    <section id="demos" class="invisible">
      <div id="liveView" class="videoView">
        <button id="webcamButton" class="mdc-button mdc-button--raised">
          <span class="mdc-button__ripple"></span>
          <span class="mdc-button__label">ENABLE WEBCAM</span>
        </button>
        <div style="position: relative">
          <video id="webcam" autoplay playsinline></video>
          <canvas
            class="output_canvas"
            id="output_canvas"
            width="1280"
            height="720"
            style="position: absolute; left: 0px; top: 0px"
          ></canvas>
          <p id="gesture_output" class="output"></p>
        </div>
      </div>

      <!-- Nueva sección para mostrar los últimos gestos -->
      <div id="lastGestures">
        <h2>Últimos 3 Gestos:</h2>
        <ul id="gestureList"></ul>
      </div>
    </section>

    <script id="rendered-js" type="module">
      import {
        GestureRecognizer,
        FilesetResolver,
        DrawingUtils,
      } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

      const demosSection = document.getElementById("demos");
      let gestureRecognizer;
      let runningMode = "IMAGE";
      let enableWebcamButton;
      let webcamRunning = false;
      const videoHeight = "360px";
      const videoWidth = "480px";

      const createGestureRecognizer = async () => {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
            delegate: "GPU",
          },
          runningMode: runningMode,
        });
        demosSection.classList.remove("invisible");
      };

      createGestureRecognizer();

      const imageContainers = document.getElementsByClassName("detectOnClick");
      for (let i = 0; i < imageContainers.length; i++) {
        imageContainers[i].children[0].addEventListener("click", handleClick);
      }

      const lastGestures = [];

      function addLastGesture(gesture) {
        // Verificar si el gesto ya está en la lista
        if (gesture != lastGestures[2]) {
          // Agregar el gesto solo si no está en la lista
          lastGestures.push(gesture);

          // Limitar la lista a los últimos 5 gestos
          if (lastGestures.length > 3) {
            lastGestures.shift();
          }

          // Actualizar la visualización de la lista de gestos en la interfaz
          updateLastGesturesUI();
        }
      }

      function updateLastGesturesUI() {
        const gestureListElement = document.getElementById("gestureList");
        gestureListElement.innerHTML = "";
        lastGestures.forEach((gesture, index) => {
          const listItem = document.createElement("li");
          listItem.textContent = `Gesto ${index + 1}: ${gesture}`;
          gestureListElement.appendChild(listItem);
        });
        checkPassword(); // Verificar la contraseña después de cada actualización
      }

      function checkPassword() {
        const desiredSequence = ["Thumb_Up", "Closed_Fist", "Thumb_Down"]; // Reemplaza con la secuencia deseada
        const currentSequence = lastGestures.slice(-desiredSequence.length);
        if (arraysAreEqual(currentSequence, desiredSequence)) {
          alert("¡Contraseña correcta!");
        }
      }

      function arraysAreEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) return false;
        for (let i = 0; i < arr1.length; i++) {
          if (arr1[i] !== arr2[i]) return false;
        }
        return true;
      }

      async function handleClick(event) {
        if (!gestureRecognizer) {
          alert("Please wait for gestureRecognizer to load");
          return;
        }

        if (runningMode === "VIDEO") {
          runningMode = "IMAGE";
          await gestureRecognizer.setOptions({ runningMode: "IMAGE" });
        }

        const allCanvas =
          event.target.parentNode.getElementsByClassName("canvas");
        for (var i = allCanvas.length - 1; i >= 0; i--) {
          const n = allCanvas[i];
          n.parentNode.removeChild(n);
        }

        const results = gestureRecognizer.recognize(event.target);
        console.log(results);

        if (results.gestures.length > 0) {
          const categoryName = results.gestures[0][0].categoryName;

          if (categoryName !== "None") {
            addLastGesture(categoryName);
          }

          const p = event.target.parentNode.childNodes[3];
          p.setAttribute("class", "info");

          const categoryScore = parseFloat(
            results.gestures[0][0].score * 100
          ).toFixed(2);
          const handedness = results.handednesses[0][0].displayName;

          p.innerText = `GestureRecognizer: ${categoryName}\n Confidence: ${categoryScore}%\n Handedness: ${handedness}`;
          p.style =
            "left: 0px;" +
            "top: " +
            event.target.height +
            "px; " +
            "width: " +
            (event.target.width - 10) +
            "px;";

          const canvas = document.createElement("canvas");
          canvas.setAttribute("class", "canvas");
          canvas.setAttribute("width", event.target.naturalWidth + "px");
          canvas.setAttribute("height", event.target.naturalHeight + "px");
          canvas.style =
            "left: 0px;" +
            "top: 0px;" +
            "width: " +
            event.target.width +
            "px;" +
            "height: " +
            event.target.height +
            "px;";

          event.target.parentNode.appendChild(canvas);

          const canvasCtx = canvas.getContext("2d");
          const drawingUtils = new DrawingUtils(canvasCtx);

          for (const landmarks of results.landmarks) {
            drawingUtils.drawConnectors(
              landmarks,
              GestureRecognizer.HAND_CONNECTIONS,
              {
                color: "#00FF00",
                lineWidth: 5,
              }
            );

            drawingUtils.drawLandmarks(landmarks, {
              color: "#FF0000",
              lineWidth: 1,
            });
          }
        }
      }

      const video = document.getElementById("webcam");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const gestureOutput = document.getElementById("gesture_output");

      function hasGetUserMedia() {
        return !!(
          navigator.mediaDevices && navigator.mediaDevices.getUserMedia
        );
      }

      if (hasGetUserMedia()) {
        enableWebcamButton = document.getElementById("webcamButton");
        enableWebcamButton.addEventListener("click", enableCam);
      } else {
        console.warn("getUserMedia() is not supported by your browser");
      }

      function enableCam(event) {
        if (!gestureRecognizer) {
          alert("Please wait for gestureRecognizer to load");
          return;
        }

        if (webcamRunning === true) {
          webcamRunning = false;
          enableWebcamButton.innerText = "ENABLE PREDICTIONS";
        } else {
          webcamRunning = true;
          enableWebcamButton.innerText = "DISABLE PREDICTIONS";
        }

        const constraints = {
          video: true,
        };

        navigator.mediaDevices
          .getUserMedia(constraints)
          .then(function (stream) {
            video.srcObject = stream;
            video.addEventListener("loadeddata", predictWebcam);
          });
      }

      let lastVideoTime = -1;
      let results = undefined;

      async function predictWebcam() {
        const webcamElement = document.getElementById("webcam");

        if (runningMode === "IMAGE") {
          runningMode = "VIDEO";
          await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
        }

        let nowInMs = Date.now();

        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime;
          results = gestureRecognizer.recognizeForVideo(video, nowInMs);
        }

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        const drawingUtils = new DrawingUtils(canvasCtx);

        canvasElement.style.height = videoHeight;
        webcamElement.style.height = videoHeight;
        canvasElement.style.width = videoWidth;
        webcamElement.style.width = videoWidth;

        if (results.landmarks) {
          for (const landmarks of results.landmarks) {
            drawingUtils.drawConnectors(
              landmarks,
              GestureRecognizer.HAND_CONNECTIONS,
              {
                color: "#00FF00",
                lineWidth: 5,
              }
            );

            drawingUtils.drawLandmarks(landmarks, {
              color: "#FF0000",
              lineWidth: 2,
            });
          }
        }

        canvasCtx.restore();

        if (results.gestures.length > 0) {
          gestureOutput.style.display = "block";
          gestureOutput.style.width = videoWidth;

          const categoryName = results.gestures[0][0].categoryName;
          const categoryScore = parseFloat(
            results.gestures[0][0].score * 100
          ).toFixed(2);
          const handedness = results.handednesses[0][0].displayName;

          gestureOutput.innerText = `GestureRecognizer: ${categoryName}\n Confidence: ${categoryScore} %\n Handedness: ${handedness}`;

          if (categoryName !== "None") {
            addLastGesture(categoryName);
          }
        } else {
          gestureOutput.style.display = "none";
        }

        if (webcamRunning === true) {
          window.requestAnimationFrame(predictWebcam);
        }
      }
    </script>
  </body>
</html>
